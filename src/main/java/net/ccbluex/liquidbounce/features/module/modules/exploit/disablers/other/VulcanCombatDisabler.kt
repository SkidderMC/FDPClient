package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.IntegerValue
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.client.C0BPacketEntityAction
import java.util.*
import kotlin.math.abs
import kotlin.random.Random

class VulcanCombatDisabler : DisablerMode("VulcanCombat") {
    private val compDecValue = BoolValue("VulcanDecrease", true)
    private val statDecValue = IntegerValue("VulcanDecreaseDelay", 1500, 500, 2500).displayable { compDecValue.get() }
    private val dynamicValue = BoolValue("VulcanDynamicDelay", true)
    private val decDelayMinValue = IntegerValue("VulcanMinDelay", 4500, 2000, 8000).displayable { dynamicValue.get() }
    private val decDelayMaxValue = IntegerValue("VulcanMaxDelay", 5500, 2000, 8000).displayable { dynamicValue.get() }
    private val minBuffValue = IntegerValue("VulcanMinBuff", 5, 0, 12)
    private val noC0BValue = BoolValue("NoC0BPacket", false)
    private var currentTrans = 0
    
    //已经死了一半的Disabler，稍微复活一下。已经无法（只靠这个Disabler）绕过的Bypass：Vanilla Velocity / None Rotation
    
    private var currentDelay = 5000
    private var currentBuffer = 4
    private var currentDec = -1
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private val lagTimer = MSTimer()
    private val decTimer = MSTimer()
    override fun onEnable() {
        packetBuffer.clear()
        updateLagTime()
    }
    override fun onUpdate(event: UpdateEvent) {
        if (lagTimer.hasTimePassed(currentDelay.toLong()) && packetBuffer.size > currentBuffer) {
            updateLagTime()
            while (packetBuffer.size > currentBuffer) {
                PacketUtils.sendPacketNoEvent(packetBuffer.poll())
                disabler.debugMessage("C0F-PingTickCounter RELEASE")
            }
        }
        if (decTimer.hasTimePassed(currentDec.toLong()) && currentDec > 0) {
            PacketUtils.sendPacketNoEvent(packetBuffer.poll())
            disabler.debugMessage("C0F-PingTickCounter DECREASE")
            decTimer.reset()
        }
    }
    override fun onWorld(event: WorldEvent) {
        currentTrans = 0
        packetBuffer.clear()
        updateLagTime()
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (packet is C0BPacketEntityAction && noC0BValue.get()) {
            event.cancelEvent()
            disabler.debugMessage("C0B-EntityAction CANCELLED")
        }
        if (packet is C0FPacketConfirmTransaction) {
            val transUID = (packet.uid).toInt()
            if (transUID >= -25767 && transUID <= -24769) {
                packetBuffer.add(packet)
                event.cancelEvent()
                disabler.debugMessage("C0F-PingTickCounter IN ${packetBuffer.size}")
            }else if (transUID == -30000){
                packetBuffer.add(packet)
                event.cancelEvent()
                disabler.debugMessage("C0F-OnSpawn IN ${packetBuffer.size}")
            }else if (transUID >= -25767 && transUID <= -25760) {
                packetBuffer.add(packet)
                event.cancelEvent()
                disabler.debugMessage("C0F-PingTickCounter RESETED")
            }else if (transUID >= -31767 && transUID <= -30769) {
                event.cancelEvent()
                disabler.debugMessage("C0F-VelocityReceived CANCELLED")
            }
        }
    }
    fun updateLagTime() {
        decTimer.reset()
        lagTimer.reset()
        if (dynamicValue.get()) {
            currentDelay = Random.nextInt(decDelayMinValue.get(), decDelayMaxValue.get())
        }else {
            currentDelay = 5000
        }
        if (compDecValue.get()) {
            currentDec = statDecValue.get()
        }else {
            currentDec = -1
        }
        currentBuffer = minBuffValue.get()
    }
}
