package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import java.util.*

class FakeLag : DisablerMode("FakeLag") {
    private val fakeLagPosValue = BoolValue("${valuePrefix}Position", true)
    private val fakeLagBlockValue = BoolValue("${valuePrefix}Block", true)
    private val fakeLagAttackValue = BoolValue("${valuePrefix}Attack", true)
    private val fakeLagSpoofValue = BoolValue("${valuePrefix}C03Spoof", false)
    private val lagDelayValue = IntegerValue("${valuePrefix}LagDelay", 0, 0, 2000)
    private val lagDurationValue = IntegerValue("${valuePrefix}LagDuration", 200, 100, 1000)
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private var isSent = false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()
    override fun onEnable() {
        isSent = false
        packetBuffer.clear()
    }
    override fun onDisable() {
        for (packet in packetBuffer) {
            PacketUtils.sendPacketNoEvent(packet)
        }
        packetBuffer.clear()
    }

    override fun onWorld(event: WorldEvent) {
        isSent = false
        fakeLagDuration.reset()
        fakeLagDelay.reset()
        packetBuffer.clear()
    }

    override fun onUpdate(event: UpdateEvent) {
        if (!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
        // Send
        if (fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
            fakeLagDelay.reset()
            fakeLagDuration.reset()
            for (packet in packetBuffer) {
                PacketUtils.sendPacketNoEvent(packet)
            }
            disabler.debugMessage("Release buf(size=${packetBuffer.size})")
            isSent = true
            packetBuffer.clear()
        }
    }
    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if (fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
            if (isSent && fakeLagSpoofValue.get()) {
                PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                if (lagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                isSent = false
            }
            if (packet is C00PacketKeepAlive || packet is C0FPacketConfirmTransaction) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
            if (fakeLagAttackValue.get() && (packet is C02PacketUseEntity || packet is C0APacketAnimation)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                if (packet is C0APacketAnimation) return
            }
            if (fakeLagBlockValue.get() && (packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
            if (fakeLagPosValue.get() && (packet is C03PacketPlayer || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook || packet is C0BPacketEntityAction)) {
                event.cancelEvent()
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
            }
        }
    }
}