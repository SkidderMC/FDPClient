/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import me.zywl.fdpclient.event.PacketEvent
import me.zywl.fdpclient.event.Render2DEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.Rotation
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S32PacketConfirmTransaction
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.Packet

/**
 * A disabler that delay transaction on some anticheat like Grim (<=2.3.59) and old Intave
 * @author Fyxar
 */
class DelayedTranscation : DisablerMode("DelayedTranscation") {
    private val holdSeconds = IntegerValue("HoldSeconds", 20, 1, 50)
    private val timer = MSTimer()

    private var delay = false
    private var lastRotation = Rotation(0f, 0f)

    private val packets = mutableListOf<Packet<INetHandlerPlayServer>>()

    override fun onEnable() {
        timer.reset()
    }

    override fun onDisable() {
        mc.timer.timerSpeed = 1F

        if (mc.thePlayer != null)
            packets.forEach { PacketUtils.sendPacketNoEvent(it)}

        packets.clear()
        delay = false
    }

    fun onRender2D(event: Render2DEvent) {
        if (delay) {
            val seconds = timer.reachedTime / 1000L
            ClientUtils.displayChatMessage("Anticheat will be back after ${holdSeconds.get() - seconds} seconds")
        }
    }

    override fun onPacket(event: PacketEvent) {
        if (mc.thePlayer == null || mc.thePlayer.ticksExisted < 20) {
            packets.clear()
            return
        }

        val packet = event.packet

        if (packet is S08PacketPlayerPosLook) {
            if (mc.thePlayer.capabilities.isFlying || mc.thePlayer.capabilities.allowFlying) {
                if (!delay) {
                    timer.reset()
                    delay = true
                }
            }
        }

        if (delay) {
            if (timer.hasTimePassed(holdSeconds.get() * 1000L)) {
                packets.forEach {PacketUtils.sendPacketNoEvent(it)}
                delay = false
                packets.clear()
                timer.reset()
            }

            if (packet is S32PacketConfirmTransaction) {
                packets.add(packet as Packet<INetHandlerPlayServer>)
                event.cancelEvent()

                PacketUtils.sendPacketNoEvent(C0FPacketConfirmTransaction())
            }
        }

    }
}