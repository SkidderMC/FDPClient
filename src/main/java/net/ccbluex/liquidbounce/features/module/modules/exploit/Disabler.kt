package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S00PacketKeepAlive
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import sun.reflect.Reflection
import java.util.*
import java.util.concurrent.ThreadLocalRandom
import java.util.concurrent.atomic.AtomicBoolean
import net.minecraft.network.PacketBuffer
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {
    private val modeValue= ListValue("Mode",arrayOf("MineplexCombat","OldHypixel","OldVerusCombat","OldVerusCombat2","OldVerusMove",/*"Spartan-Old","Spartan-b368","Spartan-b372","OldIntave",*/"Flying","Spectate","SpectateSpoof","SpectateSpoof2","VulcanGeyser","C13+InfiniteC0C","NoGroundTouch","NoGroundTouch2","OldMatrixScaffold","FakeLag","hypixelTest","HypixelTimer"),"MinePlexCombat")
    private val debug = BoolValue("Debug", false)
    private val memeAACValue = BoolValue("OldMatrixWithAAC5", false).displayable{ modeValue.equals("OldMatrixScaffold") }
    private val fakeLagPosValue = BoolValue("FakeLagPosition", true).displayable{ modeValue.equals("FakeLag") }
    private val fakeLagBlockValue = BoolValue("FakeLagBlock", true).displayable{ modeValue.equals("FakeLag") }
    private val fakeLagAttackValue = BoolValue("FakeLagAttack", true).displayable{ modeValue.equals("FakeLag") }
    private val fakeLagSpoofValue = BoolValue("FakeLagC03Spoof", false).displayable{ modeValue.equals("FakeLag") }
    private val lagDelayValue = IntegerValue("LagDelay",0,0,2000).displayable{ modeValue.equals("FakeLag") }
    private val lagDurationValue = IntegerValue("LagDuration",200,100,1000).displayable{ modeValue.equals("FakeLag") }
    private val sendTPValue = BoolValue("NoIdea-SendTP", true)
    private val sendDelayValue = IntegerValue("NoIdea-TPDelay", 3000, 0, 10000)

    private var map2 = LinkedHashMap<C00PacketKeepAlive, Long>()
    private var map2de = LinkedList<C0FPacketConfirmTransaction>()
    private var switcher = AtomicBoolean()
    private var choose = 2
    private var coo = -1
    private val c0fs=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var verus2Stat=false
    private var packetBuffer=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var fakeLagTestC00=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var fakeLagTestC0F=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var currentTrans=0
    private var memeTick=0
    private var isSent=false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()

    override fun onEnable() {
        reset()
    }
    
    override fun onDisable() {
        when(modeValue.get().lowercase()){
            "oldmatrixscaffold" -> {
                for(packet in packetBuffer){
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "fakelag" -> {
                for(packet in packetBuffer){
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "hypixeltest" -> {
                while (map2de.isEmpty()) {
                    val p: C0FPacketConfirmTransaction = map2de.poll()
                    mc.netHandler.addToSendQueue(p)
                }

                map2.entries.stream().forEachOrdered { (key): Map.Entry<C00PacketKeepAlive?, Long?> ->
                    mc.netHandler.addToSendQueue(key)
                    map2.remove(key)
                }

            }
        }
    }
    @EventTarget
    fun onTick(event: TickEvent) {
        map2.entries.stream().filter { (_, value): Map.Entry<C00PacketKeepAlive?, Long> -> value <= System.currentTimeMillis() }.forEachOrdered { (key): Map.Entry<C00PacketKeepAlive?, Long?> ->
            mc.netHandler.addToSendQueue(key)
            map2.remove(key)
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent){
        reset()
    }

    private fun reset(){
        memeTick=0
        currentTrans=0
        verus2Stat=false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent){
        when(modeValue.get().lowercase()){
            "oldveruscombat2" -> {
                mc.timer.timerSpeed = 0.6F
                if (mc.thePlayer.ticksExisted % 50 == 0 && (packetBuffer.size - 1) > currentTrans) {
                    verus2Stat = true
                    PacketUtils.sendPacketNoEvent(packetBuffer[++currentTrans])
                    debugMessage("Send Trans")
                }
                if (mc.thePlayer.ticksExisted % 500 == 0) {
                    packetBuffer.clear()
                    debugMessage("Clear Trans")
                    currentTrans = 0
                }
            }

            "oldverusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    // grab packets untill the queue size is 22 or less.
                    while (packetBuffer.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        PacketUtils.sendPacketNoEvent(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            "oldmatrixscaffold" -> {
                memeTick++
                val cTick=if(memeAACValue.get()){
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*10).roundToInt()
                }else{
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*7.6).roundToInt()
                }
                if(memeTick>=cTick){
                    memeTick=0
                    for(packet in packetBuffer){
                        PacketUtils.sendPacketNoEvent(packet)
                    }

                    debugMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }
            
            "fakelag" -> {
                if(!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                //Send
                if(fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for(packet in packetBuffer){
                        PacketUtils.sendPacketNoEvent(packet)
                    }
                    debugMessage("Release buf(size=${packetBuffer.size})")
                    isSent=true
                    packetBuffer.clear()
                }
            }
        }
    }


    @EventTarget
    fun onPacket(event: PacketEvent){
        val packet=event.packet

        when(modeValue.get().lowercase()){
            "mineplexcombat" -> {
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key-RandomUtils.nextInt(1000, 2147483647)))
                    debugMessage("Packet C00")
                }
            }

            "oldhypixel" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                    debugMessage("Packet C0F")
                }
            }

            "oldveruscombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if(packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
            }

            "oldveruscombat2" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (!verus2Stat) {
                        packetBuffer.add(packet)
                        debugMessage("Add Packet")
                        event.cancelEvent()
                    } else {
                        verus2Stat = false
                    }
                }else if (packet is C00PacketKeepAlive) {
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(RandomUtils.nextInt(1, 2147483647)))
                    debugMessage("Keep Alive")
                    event.cancelEvent()
                }else if (packet is C03PacketPlayer) {
                    PacketUtils.sendPacketNoEvent(C0CPacketInput())
                    if (mc.thePlayer.ticksExisted % 15 == 0) {
                        packet.y += RandomUtils.nextInt(100, 1000)
                        debugMessage("Packet C03")
                    }
                }
            }

            "oldverusmove" -> {
                if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0) packetBuffer.clear()
                if (packet is C03PacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                        PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    }
                } else if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                } else if (packet is C0FPacketConfirmTransaction) {
                    for (i in 0..3) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                    }
                    event.cancelEvent()
                }
            }

            "kauri" -> {
                if (packet is C0FPacketConfirmTransaction)
                    event.cancelEvent()
            }

            "ridingspoof" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
            }

            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive)
                    event.cancelEvent()
            }

            "nogroundtouch2" -> {
                if (packet is C03PacketPlayer)
                    packet.y += 0.125
            }

            "spectate" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
            }
            
            "spectatespoof" -> {
                if (packet is C03PacketPlayer) {
                    packet.onGround = false

                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }
            
            "spectatespoof2" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }


            "flying" -> {
                if (packet is C03PacketPlayer) {
                    val capabilities=PlayerCapabilities() // flags=2
                    capabilities.disableDamage=false
                    capabilities.isFlying=true
                    capabilities.allowFlying=false
                    capabilities.isCreativeMode=false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    debugMessage("Packet C13")
                }
            }
        
            "oldmatrixscaffold" -> {
                if(packet is C03PacketPlayer&&!(packet is C04PacketPlayerPosition||packet is C05PacketPlayerLook ||packet is C06PacketPlayerPosLook)){
                    event.cancelEvent()
                }
                if(packet is C02PacketUseEntity||packet is C04PacketPlayerPosition||packet is C05PacketPlayerLook
                    ||packet is C06PacketPlayerPosLook||packet is C07PacketPlayerDigging||packet is C08PacketPlayerBlockPlacement
                    ||packet is C0APacketAnimation||packet is C0BPacketEntityAction){
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }
            
            "fakelag" -> {
                if(fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if(isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        if(lagDurationValue.get()>=300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        isSent = false
                    }
                    if(packet is C00PacketKeepAlive||packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagAttackValue.get()&&(packet is C02PacketUseEntity||packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if(packet is C0APacketAnimation) return
                    }
                    if(fakeLagBlockValue.get()&&(packet is C07PacketPlayerDigging||packet is C08PacketPlayerBlockPlacement||packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagPosValue.get()&&(packet is C03PacketPlayer||packet is C04PacketPlayerPosition||packet is C05PacketPlayerLook||packet is C06PacketPlayerPosLook||packet is C0BPacketEntityAction)){
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }
            "oldhypixelfakelag" -> {
                    if(packet is C00PacketKeepAlive) {
                        event.cancelEvent()
                        fakeLagTestC00.add(packet as Packet<INetHandlerPlayServer>)
                                            if(fakeLagTestC00.count() >= 5){
                                        for(p in fakeLagTestC0F){
                    PacketUtils.sendPacketNoEvent(p)
                }
                fakeLagTestC0F.clear()
                    }
                    }
                    if(packet is C0FPacketConfirmTransaction) {
                        val packetConfirmTransaction = packet
                        if (packetConfirmTransaction.getWindowId() < 0 && packetConfirmTransaction.getWindowId() == 0) {
                        event.cancelEvent()
                        fakeLagTestC0F.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagTestC0F.count() >= 5){
                                        for(p in fakeLagTestC0F){
                    PacketUtils.sendPacketNoEvent(p)
                }
                fakeLagTestC0F.clear()
                    }
                }
            }
            "hypixeltest" -> {
                /*while (!Ascaacn.module.impl.exploit.DisablerMod.map2de.isEmpty()) {
                    val p: C0FPacketConfirmTransaction = Ascaacn.module.impl.exploit.DisablerMod.map2de.poll()
                    mc.netHandler.addToSendQueueSilent(p)
                }*/
                if (packet is S00PacketKeepAlive) {
                    val ke = packet
                    //ke.id = ke.id
                    //^ This code used for initialization variables, do not change!
                    //  Não modifique este código, este código é usado para inicializar a variável!
                    //  不要修改此代码，此代码用于初始化变量！
                    //  このコードを変更しないで、このコードは変数を初期化するために使用されます！
                    val fooClass = ke.javaClass
                    val messageField = fooClass.getDeclaredField("id")
                    messageField.isAccessible = true
                    map2.put(C00PacketKeepAlive(messageField.getInt(fooClass)), System.currentTimeMillis() + 210L)
                    event.cancelEvent();
                }
                if (packet is S08PacketPlayerPosLook) {
                    if (map2de.isEmpty()) {


//              for(int i = 0; i < 7 ; i++)
//                  Minecraft.getNetHandler().getNetworkManager().sendPacketNoEvent(new C03PacketPlayer(true));
                        while (map2de.isEmpty()) {
                            val p: C0FPacketConfirmTransaction = map2de.poll()
                            mc.netHandler.addToSendQueue(p)
                        }
                       ClientUtils.displayChatMessage("Disabler 5s, Lag Back Received.")
                        //ChatUtil.printChat("[Disabler] Received");
                    }
                }
                if (packet is C0FPacketConfirmTransaction) {
                    if (packet.windowId != 0) this.choose = packet.windowId
                    if (packet.windowId == 0 && mc.thePlayer != null && mc.theWorld != null) {
                        if (this.switcher.get()) {
                            if (ThreadLocalRandom.current().nextBoolean()) {
                                val fooClass = packet.javaClass
                                val messageField = fooClass.getDeclaredField("windowId")
                                messageField.isAccessible = true
                                messageField.set(fooClass,choose)

                                val messageField2 = fooClass.getDeclaredField("uid")
                                messageField2.isAccessible = true
                                messageField2.set(fooClass,Math.abs(packet.uid.toInt()).toShort())
                            }
                            map2de.offer(packet)
                            event.cancelEvent()
                        }
                        if (Math.abs(packet.uid.toInt()) - Math.abs(coo) == 1) switcher.set(true)
                        coo = packet.uid.toInt()
                    }
                }
            }
            "hypixeltimer" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if(c0fs.size>=5){
                        for (pack in c0fs) {
                            PacketUtils.sendPacketNoEvent(pack)
                        }
                    }else{
                        (packet as C0FPacketConfirmTransaction?)?.let { c0fs.add(it) }
                    }
                }
            }
            "nogroundtouch" -> {
                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX,
                    mc.thePlayer.posY + .125, mc.thePlayer.posZ, true))
            }

            "c13+infinitec0c" -> {
                PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                PacketUtils.sendPacketNoEvent(C0CPacketInput(Float.MAX_VALUE, Float.MAX_VALUE, false, false))
            }

            // 俩空壳
//            "AAC5Scaffold" -> { // Thank for C08Packet's help
//                if (packet is C08PacketPlayerBlockPlacement) {
//                    mc.netHandler.addToSendQueue(C03PacketPlayer())
//                    mc.netHandler.addToSendQueue(C07PacketPlayerDigging())
//                    mc.netHandler.addToSendQueue(C0FPacketConfirmTransaction(0, if (queueID.isEmpty()) uid else queueID.poll(), false))
//                }
//            }
//            "AAC3" -> { // Thank for C08Packet's help
//                if (packet is C03PacketPlayer) {
//                    mc.netHandler.addToSendQueue(C07PacketPlayerDigging())
//                    packet.y += 0.1
//                    packet.x += 0.1
//                    packet.z += 0.1
//                }
//                if (packet is C08PacketPlayerBlockPlacement) {
//                    packet.placedBlockOffsetX
//                    packet.placedBlockOffsetY
//                    packet.placedBlockOffsetZ
//                    packet.placedBlockDirection
//                }
//                if (packet is C0FPacketConfirmTransaction) {
//                    val packetConfirmTransaction = packet
//                    if (packetConfirmTransaction.getWindowId() < 0 && packetConfirmTransaction.getWindowId() == 0) {
//                        event.cancelEvent()
//                        mc.netHandler.addToSendQueue(C0FPacketConfirmTransaction(0, if (queueID.isEmpty()) uid else queueID.poll(), false))
//                        queueID.offer(packetConfirmTransaction.getUid())
//                    }
//                }
//            }
        }
    }

    private fun debugMessage(str: String){
        if(debug.get())
            chat(" [Disabler] $str")
    }

    override val tag: String
        get() = modeValue.get()
}
