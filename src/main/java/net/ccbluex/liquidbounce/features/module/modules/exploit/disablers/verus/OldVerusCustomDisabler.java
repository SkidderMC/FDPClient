/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.verus;

import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.MoveEvent;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.WorldEvent;
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode;
import net.ccbluex.liquidbounce.utils.PacketUtils;
import net.ccbluex.liquidbounce.value.BoolValue;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0BPacketEntityAction;

import java.util.concurrent.ConcurrentLinkedQueue;

public final class OldVerusCustomDisabler extends DisablerMode {
    public OldVerusCustomDisabler() {
        super("OldVerusCustomDisabler");
    }

    private final BoolValue movementDisabler = new BoolValue("Movement", false);
    private final BoolValue sprintDisabler = new BoolValue("Sprint", false);

    private final ConcurrentLinkedQueue<Packet<?>> transactions = new ConcurrentLinkedQueue<>();
    private final ConcurrentLinkedQueue<Packet<?>> keepAlives = new ConcurrentLinkedQueue<>();

    private boolean teleported;

    @EventTarget
    public void onMove(final MoveEvent event) {
        if (movementDisabler.getValue()) {
            if (mc.thePlayer.ticksExisted % 100 == 0) {
                PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.onGround));
                PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, -0.015625, mc.thePlayer.posZ, false));
                PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, mc.thePlayer.onGround));

                teleported = true;
            }
        }

        if (sprintDisabler.getValue()) {
            PacketUtils.sendPacketNoEvent(new C0BPacketEntityAction(mc.thePlayer,
                    mc.thePlayer.ticksExisted % 2 == 0 ? C0BPacketEntityAction.Action.STOP_SPRINTING :
                            C0BPacketEntityAction.Action.START_SPRINTING));
        }
    }

    @EventTarget
    public void onPacket(final PacketEvent event) {
        final Packet<?> packet = event.getPacket();

        if (sprintDisabler.getValue() && packet instanceof C0BPacketEntityAction) {
            C0BPacketEntityAction c0b = ((C0BPacketEntityAction) packet);

            if (c0b.getAction() == C0BPacketEntityAction.Action.START_SPRINTING ||
                    c0b.getAction() == C0BPacketEntityAction.Action.STOP_SPRINTING) {
                event.cancelEvent();
            }
        }
    }

    @EventTarget
    public void onWorld(final MoveEvent event) {
        if (movementDisabler.getValue()) {
            if (teleported) {
                event.cancelEvent();
            }

            teleported = false;
        }
    }

    @Override
    public void onWorld(final WorldEvent event) {
        transactions.clear();
        keepAlives.clear();
        teleported = false;
    };
}