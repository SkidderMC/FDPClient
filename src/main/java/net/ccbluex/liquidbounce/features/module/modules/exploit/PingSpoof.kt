/*
 * FDPClient Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge by LiquidBounce.
 * https://github.com/SkidderMC/FDPClient/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.modules.combat.Velocity
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.timing.TimeUtils.randomDelay
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.FloatValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import net.minecraft.network.play.server.S14PacketEntity.S16PacketEntityLook
import java.util.*
import kotlin.concurrent.schedule

object PingSpoof : Module("PingSpoof", Category.EXPLOIT, hideModule = false) {

    private val pingOnly by BoolValue("PingOnly", false)

    private val spoofDelay by IntegerValue("SpoofDelay", 500, 0..25000)

    private val maxDelayValue: Int by object : IntegerValue("MaxDelay", 1000, 0.. 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val minDelayValue = minDelayValue
            if (minDelayValue > newValue) set(minDelayValue)
        }
    }
    private val minDelayValue: Int by object : IntegerValue("MinDelay", 500, 0.. 5000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val maxDelayValue = maxDelayValue
            if (maxDelayValue < newValue) set(maxDelayValue)
        }
    }

    private val c00Value by BoolValue("C00", true)
    private val c0FValue by BoolValue("C0F", false)
    private val c0BValue by BoolValue("C0B", false)
    private val c13Value by BoolValue("C13", false)
    private val c16Value by BoolValue("C16", true)
    private val packetLossValue by FloatValue("PacketLoss", 0f, 0f..1f)

    private val packetQueue = LinkedHashMap<Packet<*>, Long>()

    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()

    override fun onDisable() = reset()

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (event.isCancelled || mc.thePlayer == null)
            return

        if (pingOnly) {
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        } else {
            // This should bypass simulation AntiCheat better.
            // Example: GrimAC
            if (packet is S32PacketConfirmTransaction || packet is S00PacketKeepAlive
                || packet is S19PacketEntityStatus || (packet is S12PacketEntityVelocity && !Velocity.delayMode)
                || packet is S08PacketPlayerPosLook ||  packet is C0CPacketInput) {
                event.cancelEvent()

                // Use nano time for the registration time since there are chances
                // the packets can be under the same milliseconds and mess up the order
                synchronized(packetQueue) {
                    packetQueue[packet] = System.currentTimeMillis()
                }
            }
        }

        if (((packet is C00PacketKeepAlive && c00Value) || (packet is C0FPacketConfirmTransaction && c0FValue) ||
                    (packet is C0BPacketEntityAction && c0BValue) || (packet is C13PacketPlayerAbilities && c13Value) ||
                    (packet is C16PacketClientStatus && c16Value))) {
            event.cancelEvent()
            if (packetLossValue == 0f || Math.random() > packetLossValue) {
                packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                queuePacket(randomDelay(minDelayValue, maxDelayValue).toLong())
            }
        }
    }

    private /*suspend*/ fun queuePacket(delayTime: Long) {
        Timer().schedule(delayTime) {
            if (this@PingSpoof.state) {
                sendPacket(packetBuffer.poll())
            }
        }
    }

    @EventTarget
    fun onGameLoop(event: GameLoopEvent) = sendPacketsByOrder(false)

    @EventTarget
    fun onWorld(event: WorldEvent) = packetQueue.clear()

    // Accept packets that have passed the requested delay, then sort by registration time
    private fun sendPacketsByOrder(all: Boolean) =
        synchronized(packetQueue) {
            packetQueue.entries.removeAll { (packet, timestamp) ->
                if (all || timestamp <= (System.currentTimeMillis() - spoofDelay)) {
                    PacketUtils.queuedPackets.add(packet)
                    true
                } else false
            }
        }

    private fun reset() {
        sendPacketsByOrder(true)

        packetQueue.clear()
    }
}
