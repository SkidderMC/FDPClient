package net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.other

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.MotionEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.world.Scaffold
import net.ccbluex.liquidbounce.features.module.modules.exploit.disablers.DisablerMode
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PlayerUtils
import net.ccbluex.liquidbounce.utils.RotationUtils
import net.ccbluex.liquidbounce.utils.Rotation
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotifyType
import net.ccbluex.liquidbounce.features.value.BoolValue
import net.ccbluex.liquidbounce.features.value.IntegerValue
import net.minecraft.item.*
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S02PacketChat
import java.util.concurrent.LinkedBlockingQueue

class HypixelDisabler : DisablerMode("Hypixel") {
    private val banWarning = BoolValue("${valuePrefix}BanWarning", true)
    private val rotationChanger = BoolValue("${valuePrefix}RotationDisabler", true)
    private val c00Disabler = BoolValue("${valuePrefix}KeepAliveDisabler", false)
    private val c0BDisabler = BoolValue("${valuePrefix}C0BDisabler", false)
    private val watchDogAntiBan = BoolValue("${valuePrefix}LessFlag", false)
    private val noC03 = BoolValue("${valuePrefix}NoC03Packet", true)
    private val strafeDisabler = BoolValue("${valuePrefix}StrafeDisabler", true)
    private val strafePackets = IntegerValue("${valuePrefix}StrafeDisablerPacketAmount", 70,60, 120)
    private val timerA = BoolValue("${valuePrefix}Timer1", true)
    private val timerB = BoolValue("${valuePrefix}Timer2", false)
    private val timerBlinkPatch = BoolValue("${valuePrefix}TimerBlinkPatch", true)
    private val testBlink = BoolValue("${valuePrefix}TestBlinkSus", false)
    private var counter = 0
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0

    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayServer>>()
    private val timerCancelDelay = MSTimer()
    private val timerCancelTimer = MSTimer()
    private var timerShouldCancel = true
    private var inCage = true
    
    
    private var canBlink = true

    override fun onWorld(event: WorldEvent) {
        counter = 0
        inCage = true
    }

    override fun onEnable() {
        counter = 0
        inCage = true
        x = 0.0
        y = 0.0
        z = 0.0
        timerCancelDelay.reset()
        timerCancelTimer.reset()
    }

    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        canBlink = true
        
        //ban warning
        if (banWarning.get() && packet is S02PacketChat && packet.chatComponent.unformattedText.contains("Cages opened!", true)) {
            LiquidBounce.hud.addNotification(Notification("Disabler", "Speed is bannable until this notification disappears.", NotifyType.ERROR, 20000))
            inCage = false
        }
        
        if (mc.thePlayer.ticksExisted > 200f)
            inCage = false
            

        //timerA
        if (timerA.get() && inCage == false) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
            packet is C0APacketAnimation || packet is C0BPacketEntityAction && mc.thePlayer.ticksExisted > strafePackets.get()) {
                if (timerShouldCancel) {
                    if (!timerCancelTimer.hasTimePassed(350)) {
                        packets.add(packet as Packet<INetHandlerPlayServer>)
                        event.cancelEvent()
                        canBlink = false
                    } else {
                        disabler.debugMessage("Timer 1 release packets")
                        disabler.debugMessage("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                    if ((mc.thePlayer.isUsingItem || LiquidBounce.moduleManager[KillAura::class.java]!!.blockingStatus) && mc.thePlayer.heldItem != null && mc.thePlayer.heldItem.item is ItemSword) {
                        disabler.debugMessage("Timer 1 release packets")
                        disabler.debugMessage("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                }
            }
        }
        
        //timerB
        if (timerB.get() && inCage == false) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
            packet is C0APacketAnimation || packet is C0BPacketEntityAction && mc.thePlayer.ticksExisted > strafePackets.get()) {
                if (timerShouldCancel) {
                    if (!timerCancelTimer.hasTimePassed(250)) {
                        packets.add(packet as Packet<INetHandlerPlayServer>)
                        event.cancelEvent()
                        canBlink = false
                    } else {
                        disabler.debugMessage("Timer 2 release packets")
                        disabler.debugMessage("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                    if ((mc.thePlayer.isUsingItem || LiquidBounce.moduleManager[KillAura::class.java]!!.blockingStatus) && mc.thePlayer.heldItem != null && mc.thePlayer.heldItem.item is ItemSword) {
                        disabler.debugMessage("Timer 2 release packets")
                        disabler.debugMessage("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                }
            }
        }


        // noC03
        if (packet is C03PacketPlayer && !(packet is C03PacketPlayer.C05PacketPlayerLook || packet is C03PacketPlayer.C06PacketPlayerPosLook || packet is C03PacketPlayer.C04PacketPlayerPosition) && noC03.get()) {
            event.cancelEvent()
            canBlink = false
        }

        // strafe disabler
        if (strafeDisabler.get() && (mc.thePlayer.ticksExisted < strafePackets.get()) && packet is C03PacketPlayer && (mc.thePlayer.ticksExisted % 15 != 0)) {
            event.cancelEvent()
            canBlink = false
        }

        // anti ban
        if(watchDogAntiBan.get() || (strafeDisabler.get() && (mc.thePlayer.ticksExisted < strafePackets.get())) ){
            if (event.packet is C03PacketPlayer.C06PacketPlayerPosLook && mc.thePlayer.onGround && mc.thePlayer.fallDistance>10) {
                if (counter > 0) {
                    if (event.packet.x == x && event.packet.y == y && event.packet.z == z) {
                        mc.netHandler.networkManager.sendPacket(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                event.packet.x,
                                event.packet.y,
                                event.packet.z,
                                event.packet.onGround
                            )
                        )
                        disabler.debugMessage("Packet C04")
                        event.cancelEvent()
                    }
                }
                counter += 1

                if (event.packet is C03PacketPlayer.C05PacketPlayerLook && mc.thePlayer.isRiding) {
                    mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                    disabler.debugMessage("Packet C0B")
                } else if (event.packet is C0CPacketInput && mc.thePlayer.isRiding) {
                    mc.netHandler.networkManager.sendPacket(event.packet)
                    mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING))
                    disabler.debugMessage("Packet C0B")
                    event.cancelEvent()
                }
            }

            if (event.packet is S08PacketPlayerPosLook) {
                val s08 = event.packet
                x = s08.x
                y = s08.y
                z = s08.z
                disabler.debugMessage("Receive S08")
            }

            if (event.packet is S07PacketRespawn) {
                counter = 0
            }
        }
        
        //test
        if (testBlink.get()) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
            packet is C0APacketAnimation || packet is C0BPacketEntityAction) {
                disabler.debugMessage("Size " + packets.size.toString())
                while (!packets.isEmpty()) {
                    PacketUtils.sendPacketNoEvent(packets.take())
                }
            } else {
                if (canBlink) {
                    packets.add(packet as Packet<INetHandlerPlayServer>)
                    event.cancelEvent()
                }
            }
        }

    }
    
    override fun onMotion(event: MotionEvent) {
        if (rotationChanger.get() && !LiquidBounce.moduleManager[Scaffold::class.java]!!.state && !LiquidBounce.moduleManager[KillAura::class.java]!!.state) {
            val cYaw = MovementUtils.movingYaw
            RotationUtils.setTargetRotation(Rotation(cYaw, mc.thePlayer.rotationPitch), 10)
        }
    }

    override fun onUpdate(event: UpdateEvent) {
        
        
        // timer1
        if (timerA.get()) {
            if (timerCancelDelay.hasTimePassed(5000)) {
                timerShouldCancel = true
                timerCancelTimer.reset()
                timerCancelDelay.reset()
            }
        }
        
        // timer2
        if (timerB.get()) {
            if (timerCancelDelay.hasTimePassed(2000)) {
                timerShouldCancel = true
                timerCancelTimer.reset()
                timerCancelDelay.reset()
            }
        }


        //Hypixel Disabler C00
        if (c00Disabler.get()) {
            if (mc.thePlayer.onGround && PlayerUtils.isBlockUnder() && mc.thePlayer.fallDistance > 10) {
                mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                disabler.debugMessage("Hypixel Disabler C00")
            }
        }

        //Hypixel Disabler C0B & Hypixel Disabler C03
        if (c0BDisabler.get()) {
            if (mc.thePlayer.ticksExisted % 180 == 90) {
                if (mc.thePlayer.onGround && mc.thePlayer.fallDistance > 10) {
                    mc.netHandler.addToSendQueue(C00PacketKeepAlive(RandomUtils.nextInt(0, 1000)))
                    disabler.debugMessage("Hypixel Disabler C0B")
                    mc.timer.timerSpeed = 0.8f;
                } else {
                    if (mc.thePlayer.fallDistance < 10) {
                        if (mc.thePlayer.posY == mc.thePlayer.fallDistance.toDouble()) {
                            mc.netHandler.addToSendQueue(C03PacketPlayer(false))
                            if (mc.thePlayer.onGround) mc.timer.timerSpeed = 0.4f;
                            if (mc.thePlayer.fallDistance == 0f) mc.netHandler.addToSendQueue(C03PacketPlayer(true))
                            disabler.debugMessage("Hypixel Disabler C03")
                        }
                    }
                }
            }
        }
    }
}
